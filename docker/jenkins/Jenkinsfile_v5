// Jenkinsfile

pipeline {
    agent any

    tools {
        maven "MAVEN_HOME" // Asegúrate que "MAVEN_HOME" es el nombre de tu config de Maven en Jenkins
    }

    stages {
        stage('Clone') {
            steps {
                timeout(time: 10, unit: 'MINUTES') {
                    echo "Limpiando workspace..."
                    cleanWs()
                    echo "Clonando repositorio..."
                    git branch: 'master', url: 'https://github.com/arlysanchez/ecommerce_Dockerizado.git'

                    echo "Verificando estructura de 'sql/' DESPUÉS del clone en el workspace de Jenkins:"
                    sh 'ls -la sql/'
                    sh '''
                        if [ -d "sql/init.sql" ]; then
                          echo "ERROR: sql/init.sql ES UN DIRECTORIO en el workspace de Jenkins."
                        elif [ -f "sql/init.sql" ]; then
                          echo "OK: sql/init.sql ES UN ARCHIVO en el workspace de Jenkins."
                          echo "Primeras líneas de sql/init.sql en el workspace:"
                          head -n 5 sql/init.sql
                        else
                          echo "ADVERTENCIA: sql/init.sql no es ni un archivo ni un directorio, o no existe."
                        fi
                    '''
                }
            }
        }
        stage('Build') {
            steps {
                timeout(time: 10, unit: 'MINUTES') {
                    sh "mvn -DskipTests clean package"
                }
            }
        }
        stage('Test') {
            steps {
                timeout(time: 10, unit: 'MINUTES') {
                    sh "mvn test -DskipTests"
                }
            }
        }
        stage('Sonar Analysis') {
            steps {
                timeout(time: 10, unit: 'MINUTES') {
                    withSonarQubeEnv('sonarqube') {
                        sh "mvn org.sonarsource.scanner.maven:sonar-maven-plugin:3.9.0.2155:sonar -Pcoverage"
                    }
                }
            }
        }
        stage('Quality Gate') {
            steps {
                timeout(time: 10, unit: 'MINUTES') {
                    waitForQualityGate abortPipeline: true
                }
            }
        }
        stage('Deploy Application') {
            steps {
                echo "Iniciando despliegue de la aplicación con Docker Compose..."
                dir('docker') {
                    script {
                        def dockerProjectName = "ecomapp"

                        try {
                            echo "Deteniendo y eliminando despliegue anterior (si existe)..."
                            sh "docker-compose -p ${dockerProjectName} down -v --remove-orphans --rmi local"
                            echo "Despliegue anterior detenido y limpiado."

                            echo "Intentando eliminar explícitamente el volumen ${dockerProjectName}_mysql_data..."
                            sh "docker volume rm ${dockerProjectName}_mysql_data || true"
                            echo "Intento de eliminación de volumen completado."

                        } catch (Exception e) {
                            echo "Advertencia durante la limpieza: ${e.getMessage()} (Puede que no existiera nada que limpiar)."
                            echo "Continuando con el despliegue..."
                        }
                        
                        // Mantenemos las verificaciones para confirmar que todo sigue bien antes del 'up'
                        echo "Verificando estructura de '../sql/' DESDE el directorio 'docker/' ANTES del docker-compose up:"
                        sh 'ls -la ../sql/'
                        sh '''
                            if [ -f "../sql/init.sql" ]; then
                              echo "OK PIPELINE: ../sql/init.sql ES UN ARCHIVO justo antes del montaje."
                            else
                              echo "ADVERTENCIA PIPELINE: ../sql/init.sql NO ES UN ARCHIVO justo antes del montaje."
                            fi
                        '''

                        // ---------------------------------------------------------------------
                        // --- CAMBIO CLAVE: Usar ruta absoluta para el volumen SQL ---
                        // ---------------------------------------------------------------------
                        // En lugar de llamar a 'docker-compose up' directamente, lo hacemos
                        // dentro de un bloque 'sh' que primero exporta la variable de entorno
                        // SQL_INIT_PATH. Esta variable contiene la ruta absoluta a tu carpeta 'sql'.
                        // La variable ${WORKSPACE} es proporcionada por Jenkins automáticamente.
                        echo "Construyendo imágenes y levantando servicios con ruta absoluta para el script SQL..."
                        sh """
                            export SQL_INIT_PATH=${WORKSPACE}/sql
                            docker-compose -p ${dockerProjectName} up -d --build
                        """
                        // ---------------------------------------------------------------------
                        // --- FIN DEL CAMBIO ---
                        // ---------------------------------------------------------------------

                        echo "Comando 'docker-compose up' ejecutado."

                        echo "Esperando a que los servicios se estabilicen (60 segundos)..."
                        sleep(60)
                        
                        echo "Verificando el script montado DENTRO del contenedor MySQL (AHORA DEBERÍA FUNCIONAR):"
                        sh "docker exec mysql-ecommerce-prod ls -l /docker-entrypoint-initdb.d/"
                        
                        sh '''docker exec mysql-ecommerce-prod sh -c 'if [ -f /docker-entrypoint-initdb.d/init.sql ]; then echo "¡ÉXITO! CONTENEDOR: init.sql ES UN ARCHIVO"; else echo "FALLO. CONTENEDOR: init.sql NO SE ENCONTRÓ O NO ES UN ARCHIVO"; fi' '''
                        
                        sh "docker exec mysql-ecommerce-prod sh -c 'if [ -f /docker-entrypoint-initdb.d/init.sql ]; then cat /docker-entrypoint-initdb.d/init.sql | head -n 10; else echo \"No se puede mostrar cat porque no es un archivo.\"; fi' "
                        
                        echo "Logs del contenedor MySQL (mysql-ecommerce-prod) después del 'up':"
                        sh "docker logs mysql-ecommerce-prod"

                        echo "Logs del contenedor de la Aplicación (product_app) después del 'up':"
                        sh "docker logs product_app"

                        echo "Despliegue completado. Aplicación y base de datos deberían estar corriendo."

                        echo "Esperando 90 segundos adicionales antes del health check para la aplicación..."
                        sleep(90)

                        echo "Verificando salud de la aplicación..."
                        sh "curl -v -f --connect-timeout 10 --max-time 20 http://host.docker.internal:8084/actuator/health || exit 1"
                        echo "Aplicación saludable."
                    }
                }
            }
        }
    }
    post {
        always {
            echo 'Pipeline finalizado.'
        }
        success {
            echo '¡Pipeline ejecutado con éxito!'
        }
        failure {
            echo 'Pipeline falló.'
        }
    }
}
