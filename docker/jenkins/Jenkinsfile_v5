// Jenkinsfile

pipeline {
    agent any

    tools {
        maven "MAVEN_HOME" // Asegúrate que "MAVEN_HOME" es el nombre de tu config de Maven en Jenkins
    }

    stages {
       stage('Clone') {
            steps {
                timeout(time: 2, unit: 'MINUTES') {
                    cleanWs()
                    git branch: 'master', url: 'https://github.com/arlysanchez/ecommerce_Dockerizado.git'
                    echo "Contenido de sql/init.sql ANTES de sed:"
                    sh 'cat sql/init.sql | head -n 5' // Muestra las primeras 5 líneas
                    sh 'file sql/init.sql' // Intenta obtener información del tipo de archivo y finales de línea
        
                    echo "Aplicando sed para asegurar finales de línea LF para sql/init.sql..."
                    sh '''sed -i.bak 's/\\r$//' sql/init.sql''' // Usando triple comilla simple y comillas simples para el regex de sed
        
                    echo "Contenido de sql/init.sql DESPUÉS de sed:"
                    sh 'cat sql/init.sql | head -n 5'
                    sh 'file sql/init.sql'
                    echo "Contenido del archivo de backup sql/init.sql.bak (si se creó):"
                    sh 'cat sql/init.sql.bak | head -n 5 || echo "No se creó archivo .bak o está vacío"'
                }
            }
       }
        stage('Build') {
            steps {
                timeout(time: 3, unit: 'MINUTES') { // Aumentado un poco por si acaso
                    sh "mvn -DskipTests clean package"
                }
            }
        }
        stage('Test') { // Aunque los saltas, es bueno tener la etapa
            steps {
                timeout(time: 1, unit: 'MINUTES') {
                    sh "mvn test -DskipTests" // Actualmente saltando tests
                }
            }
        }
        stage('Sonar Analysis') { // Renombrado para claridad
            steps {
                timeout(time: 3, unit: 'MINUTES') { // Aumentado un poco
                    withSonarQubeEnv('sonarqube') { // Nombre de tu server SonarQube en Jenkins
                        sh "mvn org.sonarsource.scanner.maven:sonar-maven-plugin:3.9.0.2155:sonar -Pcoverage"
                    }
                }
            }
        }
        stage('Quality Gate') { // Renombrado para claridad
            steps {
                // No es necesario un sleep aquí si SonarQube webhook está bien configurado o si el análisis es rápido.
                // El waitForQualityGate ya tiene un timeout implícito.
                timeout(time: 10, unit: 'MINUTES') { // Timeout para el quality gate en sí
                    waitForQualityGate abortPipeline: true
                }
            }
        }
        stage('Deploy Application') { // Renombrado para claridad
            steps {
                echo "Iniciando despliegue de la aplicación con Docker Compose..."
                // Navegamos al directorio donde está el docker-compose.yml de la aplicación
                dir('docker') {
                    script {
                        def dockerProjectName = "ecomapp" // Nombre de proyecto explícito para Docker Compose

                        try {
                            echo "Deteniendo y eliminando despliegue anterior (si existe)..."
                            // Usar -p para especificar un nombre de proyecto consistente
                            // Esto ayuda a asegurar que los nombres de volúmenes y redes sean predecibles.
                            sh "docker-compose -p ${dockerProjectName} down -v --remove-orphans --rmi local"
                            echo "Despliegue anterior detenido y limpiado."

                            // Opcional: Eliminar explícitamente el volumen si down -v no es suficiente
                            // El nombre del volumen será ${dockerProjectName}_mysql_data
                            echo "Intentando eliminar explícitamente el volumen ${dockerProjectName}_mysql_data..."
                            sh "docker volume rm ${dockerProjectName}_mysql_data || true"
                            echo "Intento de eliminación de volumen completado."

                        } catch (Exception e) {
                            echo "Advertencia durante la limpieza: ${e.getMessage()} (Puede que no existiera nada que limpiar)."
                            echo "Continuando con el despliegue..."
                        }

                        echo "Construyendo imágenes y levantando servicios..."
                        // Usar -p aquí también para consistencia
                        sh "docker-compose -p ${dockerProjectName} up -d --build"
                        echo "Comando 'docker-compose up' ejecutado."

                        echo "Esperando a que los servicios se estabilicen (60 segundos)..."
                        sleep(60) // Aumentado el sleep inicial
                        echo "Verificando el init.sql montado DENTRO del contenedor MySQL:"
                        sh "docker exec mysql-ecommerce-prod ls -l /docker-entrypoint-initdb.d/"
                        sh "docker exec mysql-ecommerce-prod cat /docker-entrypoint-initdb.d/init.sql | head -n 10" // Muestra las primeras 10 líneas
                        sh "docker exec mysql-ecommerce-prod file /docker-entrypoint-initdb.d/init.sql"
                        
                        echo "Logs del contenedor MySQL (mysql-ecommerce-prod) después del 'up':"
                        sh "docker logs mysql-ecommerce-prod"

                        echo "Logs del contenedor de la Aplicación (product_app) después del 'up':"
                        sh "docker logs product_app"

                        echo "Despliegue completado. Aplicación y base de datos deberían estar corriendo."
                        echo "App accesible (desde fuera de Docker) en http://<ip_de_tu_maquina_windows_o_agente_jenkins>:8084"

                        echo "Esperando 90 segundos adicionales antes del health check para la aplicación..."
                        sleep(90) // Sleep más largo antes del health check

                        echo "Verificando salud de la aplicación..."
                        sh "curl -v -f --connect-timeout 10 --max-time 20 http://host.docker.internal:8084/actuator/health || exit 1"
                        // -v para verbose output de curl, --connect-timeout y --max-time para controlar tiempos de curl
                        echo "Aplicación saludable."
                    }
                }
            }
        }
    }
    post {
        always {
            echo 'Pipeline finalizado.'
            // Aquí podrías añadir pasos de limpieza si es necesario,
            // aunque 'docker-compose down' en el inicio de Deploy debería manejarlo.
        }
        success {
            echo '¡Pipeline ejecutado con éxito!'
        }
        failure {
            echo 'Pipeline falló.'
            // Podrías añadir notificaciones aquí
        }
    }
}
